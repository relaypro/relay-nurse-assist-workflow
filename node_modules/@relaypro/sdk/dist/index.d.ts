import * as enums from './enums';
import { BaseCall, ButtonEvent, ConnectedCall, DisconnectedCall, FailedCall, ReceivedCall, StartedCall, NotificationEvent, NotificationOptions, IncidentEvent, LocalWebSocket, Options, Relay, Workflow, LedIndex, LedEffect, LedInfo, PlaceCall, Prompt, RingingCall, RegisterRequest } from './types';
declare const Event: typeof enums.Event, Language: typeof enums.Language;
export * from './enums';
declare type WorkflowEventHandlers = {
    [Event.ERROR]?: (error: Error) => Promise<void>;
    [Event.START]?: (event: Record<string, never>) => Promise<void>;
    [Event.STOP]?: (event: Record<string, never>) => Promise<void>;
    [Event.BUTTON]?: (event: ButtonEvent) => Promise<void>;
    [Event.TIMER]?: (event: Record<`name`, string>) => Promise<void>;
    [Event.NOTIFICATION]?: (event: NotificationEvent) => Promise<void>;
    [Event.INCIDENT]?: (event: IncidentEvent) => Promise<void>;
    [Event.PROMPT_START]?: (event: Prompt) => Promise<void>;
    [Event.CALL_RINGING]?: (event: RingingCall) => Promise<void>;
    [Event.CALL_CONNECTED]?: (event: ConnectedCall) => Promise<void>;
    [Event.CALL_DISCONNECTED]?: (event: DisconnectedCall) => Promise<void>;
    [Event.CALL_FAILED]?: (event: FailedCall) => Promise<void>;
    [Event.CALL_RECEIVED]?: (event: ReceivedCall) => Promise<void>;
    [Event.CALL_START_REQUEST]?: (event: StartedCall) => Promise<void>;
};
declare const createWorkflow: (fn: Workflow) => Workflow;
declare class RelayEventAdapter {
    private websocket;
    private workQueue;
    private handlers;
    constructor(websocket: LocalWebSocket);
    on<U extends keyof WorkflowEventHandlers>(event: U, listener: WorkflowEventHandlers[U]): void;
    off<U extends keyof WorkflowEventHandlers>(event: U): void;
    private onClose;
    private onError;
    private onMessage;
    private _send;
    private _sendReceive;
    private _cast;
    private _call;
    setTimer(type: enums.TimerType, name: string, timeout: number | undefined, timeout_type: enums.TimeoutType): Promise<void>;
    clearTimer(name: string): Promise<void>;
    restartDevice(): Promise<void>;
    powerDownDevice(): Promise<void>;
    say(text: string, lang?: enums.Language): Promise<string>;
    play(filename: string): Promise<string>;
    stopPlayback(id?: string | string[]): Promise<void>;
    translate(text: string, from?: enums.Language, to?: enums.Language): Promise<string>;
    vibrate(pattern: number[]): Promise<void>;
    switchLedOn(led: LedIndex, color: string): Promise<void>;
    switchAllLedOn(color: string): Promise<void>;
    switchAllLedOff(): Promise<void>;
    rainbow(rotations?: number): Promise<void>;
    rotate(color?: string): Promise<void>;
    flash(color?: string): Promise<void>;
    breathe(color?: string): Promise<void>;
    ledAction(effect: LedEffect, args: LedInfo): Promise<void>;
    private _getDeviceInfo;
    getDeviceName(): Promise<string>;
    getDeviceLocation(refresh: boolean): Promise<string>;
    getDeviceId(): Promise<string>;
    getDeviceAddress(refresh: boolean): Promise<string>;
    getDeviceCoordinates(refresh: boolean): Promise<number[]>;
    getDeviceLatLong(refresh: boolean): Promise<number[]>;
    getDeviceIndoorLocation(refresh: boolean): Promise<string>;
    getDeviceBattery(refresh: boolean): Promise<number>;
    getDeviceType(): Promise<enums.DeviceType>;
    private setDeviceInfo;
    setDeviceName(name: string): Promise<void>;
    setDeviceChannel(channel: string): Promise<void>;
    setDeviceMode(mode: `panic` | `alarm` | `none`): Promise<void>;
    setChannel(name: string, target: string[], { suppressTTS, disableHomeChannel }?: {
        suppressTTS?: boolean;
        disableHomeChannel?: false;
    }): Promise<void>;
    setVar(name: string, value: string): Promise<void>;
    set(obj: Record<string, string>, value?: string): Promise<void>;
    unsetVar(name: string): Promise<void>;
    unset(names: string | string[]): Promise<void>;
    getVar(name: string, defaultValue?: undefined): Promise<string>;
    get(names: string | string[]): Promise<string | string[]>;
    startTimer(timeout?: number): Promise<void>;
    stopTimer(): Promise<void>;
    private _sendNotification;
    broadcast(name: string, text: string, target: string[], pushOptions?: NotificationOptions): Promise<void>;
    cancelBroadcast(name: string, target: string[]): Promise<void>;
    notify(name: string, text: string, target: string[], pushOptions?: NotificationOptions): Promise<void>;
    cancelNotify(name: string, target: string[]): Promise<void>;
    alert(name: string, text: string, target: string[], pushOptions?: NotificationOptions): Promise<void>;
    cancelAlert(name: string, target: string[]): Promise<void>;
    listen(phrases?: never[], { transcribe, alt_lang, timeout }?: {
        transcribe?: boolean | undefined;
        alt_lang?: enums.Language | undefined;
        timeout?: number | undefined;
    }): Promise<Record<`text`, string> | Record<`audio`, string>>;
    createIncident(type: string): Promise<string>;
    resolveIncident(incidentId: string, reason: string): Promise<void>;
    terminate(): Promise<void>;
    private _buildCallIdRequestOrThrow;
    placeCall(call: PlaceCall): Promise<void>;
    answerCall(callRequest: string | BaseCall): Promise<void>;
    hangupCall(callRequest: string | BaseCall): Promise<void>;
    register(request: RegisterRequest): Promise<void>;
}
declare const initializeRelaySdk: (options?: Options) => Relay;
export { initializeRelaySdk as relay, createWorkflow, };
export type { RelayEventAdapter, Event, Workflow, Relay, Language, Options };
