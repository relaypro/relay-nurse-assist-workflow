"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWorkflow = exports.relay = void 0;
const tslib_1 = require("tslib");
const ws_1 = tslib_1.__importStar(require("ws"));
const enums = tslib_1.__importStar(require("./enums"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const queue_1 = tslib_1.__importDefault(require("./queue"));
const { Event, Language, DeviceInfoQuery, DeviceInfoField, Notification, } = enums;
tslib_1.__exportStar(require("./enums"), exports);
const createWorkflow = (fn) => fn;
exports.createWorkflow = createWorkflow;
const WORKFLOW_EVENT_REGEX = /^wf_api_(\w+)_event$/;
class RelayEventAdapter {
    constructor(websocket) {
        Object.defineProperty(this, "websocket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "workQueue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "handlers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        console.log(`creating event adapter`);
        this.workQueue = new queue_1.default();
        this.websocket = websocket;
        this.websocket.on(`close`, this.onClose.bind(this));
        this.websocket.on(`error`, this.onError.bind(this));
        this.websocket.on(`message`, this.onMessage.bind(this));
    }
    on(event, listener) {
        this.off(event);
        this.handlers[event] = listener;
    }
    off(event) {
        const { [event]: handler, ...rest } = this.handlers;
        if (handler) {
            this.handlers = rest;
        }
    }
    onClose() {
        this.websocket = null;
    }
    onError(error) {
        this.workQueue?.enqueue(async () => {
            if (this.handlers?.[Event.ERROR]) {
                try {
                    await this.handlers?.[Event.ERROR]?.(error);
                }
                catch (err) {
                    console.log(`\`error\` handler failed`);
                    console.error(err);
                }
            }
            else { // if no handler, log
                console.error(error);
            }
        });
    }
    onMessage(msg) {
        const message = utils_1.safeParse(msg);
        if (this.workQueue && message?._type && !message?._id) { // not interested in response events (marked by correlation id)
            const eventNameParts = message._type.match(WORKFLOW_EVENT_REGEX);
            if (eventNameParts?.[1]) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { _type, ...args } = message;
                this.workQueue?.enqueue(async () => {
                    const event = eventNameParts?.[1];
                    try {
                        await this.handlers?.[event]?.(args);
                    }
                    catch (err) {
                        this.onError(err);
                    }
                });
            }
            else {
                console.log(`Unknown message =>`, message);
            }
        }
    }
    /*
    private async stop(): Promise<void> {
      console.log(`stopping event adapter`)
      if (this.websocket) {
        console.log(`terminating event adapter websocket`)
        this.websocket.terminate()
      }
    }
    */
    async _send(type, payload = {}, id) {
        return new Promise((resolve, reject) => {
            if (!(this.websocket?.isAlive && this.websocket?.readyState === ws_1.OPEN)) {
                console.error({
                    isAlive: this.websocket?.isAlive,
                    readyState: this.websocket?.readyState,
                });
                reject(new Error(`websocket-not-connected`));
                return;
            }
            const message = {
                _id: id ?? utils_1.makeId(),
                _type: `wf_api_${type}_request`,
                ...payload,
            };
            const messageStr = JSON.stringify(message);
            this.websocket.send(messageStr, (err) => {
                if (err) {
                    reject(new Error(`failed-to-send`));
                }
                else {
                    resolve();
                }
            });
        });
    }
    async _sendReceive(type, payload = {}, timeout = constants_1.TIMEOUT) {
        const id = utils_1.makeId();
        await this._send(type, payload, id);
        return new Promise((resolve, reject) => {
            const timeoutHandle = setTimeout(() => {
                this.websocket?.off?.(`message`, responseListener);
                reject(new Error(`failed-to-receive-response-timeout`));
            }, timeout);
            const responseListener = (msg) => {
                clearTimeout(timeoutHandle);
                const event = utils_1.safeParse(msg);
                if (event) {
                    const { _id, _type, ...params } = event;
                    if (_id === id) { // interested here in response events (marked by correlation id)
                        // stop listening as soon as we have a correlated response
                        this.websocket?.off(`message`, responseListener);
                        if (_type === `wf_api_${type}_response`) {
                            resolve(Object.keys(params).length > 0 ? params : undefined);
                        }
                        else if (_type === `wf_api_error_response`) {
                            reject(new Error(event?.error ?? `Unknown error`));
                        }
                        else {
                            console.log(`Unknown response`, event);
                            reject(new Error(`Unknown response`));
                        }
                    }
                }
            };
            // start listening to websocket messages for correlated response
            this.websocket?.on(`message`, responseListener);
        });
    }
    async _cast(type, payload = {}, timeout = constants_1.TIMEOUT) {
        await this._sendReceive(type, payload, timeout);
    }
    async _call(type, payload = {}, timeout = constants_1.TIMEOUT) {
        return (await this._sendReceive(type, payload, timeout));
    }
    async setTimer(type, name, timeout = 60, timeout_type) {
        await this._cast(`set_timer`, { type, name, timeout, timeout_type });
    }
    async clearTimer(name) {
        await this._cast(`clear_timer`, { name });
    }
    async restartDevice() {
        await this._cast(`device_power_off`, { restart: true });
    }
    async powerDownDevice() {
        await this._cast(`device_power_off`, { restart: false });
    }
    async say(text, lang = Language.ENGLISH) {
        const { id } = (await this._call(`say`, { text, lang }));
        return id;
    }
    async play(filename) {
        const { id } = (await this._call(`play`, { filename }));
        return id;
    }
    async stopPlayback(id) {
        if (Array.isArray(id)) {
            await this._cast(`stop_playback`, { ids: id });
        }
        else if (typeof id === `string`) {
            await this._cast(`stop_playback`, { ids: [id] });
        }
        else {
            await this._cast(`stop_playback`, {});
        }
    }
    async translate(text, from = Language.ENGLISH, to = Language.SPANISH) {
        const { text: translatedText } = (await this._call(`translate`, { text, from_lang: from, to_lang: to }));
        return translatedText;
    }
    async vibrate(pattern) {
        await this._cast(`vibrate`, { pattern });
    }
    async switchLedOn(led, color) {
        await this.ledAction(`static`, { colors: { [`${led}`]: color } });
    }
    async switchAllLedOn(color) {
        await this.ledAction(`static`, { colors: { ring: color } });
    }
    async switchAllLedOff() {
        await this.ledAction(`off`, {});
    }
    async rainbow(rotations = -1) {
        await this.ledAction(`rainbow`, { rotations });
    }
    async rotate(color = `FFFFFF`) {
        await this.ledAction(`rotate`, { rotations: -1, colors: { [`1`]: color } });
    }
    async flash(color = `0000FF`) {
        await this.ledAction(`flash`, { count: -1, colors: { ring: color } });
    }
    async breathe(color = `0000FF`) {
        await this.ledAction(`breathe`, { count: -1, colors: { ring: color } });
    }
    async ledAction(effect, args) {
        await this._cast(`set_led`, { effect, args });
    }
    async _getDeviceInfo(query, refresh = false) {
        const response = await this._call(`get_device_info`, { query, refresh }, refresh ? constants_1.REFRESH_TIMEOUT : constants_1.TIMEOUT);
        return response[query];
    }
    async getDeviceName() {
        return await this._getDeviceInfo(DeviceInfoQuery.NAME);
    }
    async getDeviceLocation(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.ADDRESS, refresh);
    }
    async getDeviceId() {
        return await this._getDeviceInfo(DeviceInfoQuery.ID);
    }
    async getDeviceAddress(refresh) {
        return await this.getDeviceLocation(refresh);
    }
    async getDeviceCoordinates(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.COORDINATES, refresh);
    }
    async getDeviceLatLong(refresh) {
        return await this.getDeviceCoordinates(refresh);
    }
    async getDeviceIndoorLocation(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.INDOOR_LOCATION, refresh);
    }
    async getDeviceBattery(refresh) {
        return await this._getDeviceInfo(DeviceInfoQuery.BATTERY, refresh);
    }
    async getDeviceType() {
        return await this._getDeviceInfo(DeviceInfoQuery.TYPE);
    }
    async setDeviceInfo(field, value) {
        await this._cast(`set_device_info`, { field, value });
    }
    async setDeviceName(name) {
        await this.setDeviceInfo(DeviceInfoField.LABEL, name);
    }
    async setDeviceChannel(channel) {
        await this.setDeviceInfo(DeviceInfoField.CHANNEL, channel);
    }
    async setDeviceMode(mode, target) {
        await this._cast(`set_device_mode`, { mode, target });
    }
    async setChannel(name, target, { suppressTTS = false, disableHomeChannel = false } = {}) {
        await this._cast(`set_channel`, { channel_name: name, target, suppress_tts: suppressTTS, disable_home_channel: disableHomeChannel });
    }
    async setVar(name, value) {
        await this._cast(`set_var`, { name, value });
    }
    async set(obj, value) {
        if (typeof obj === `object`) {
            await Promise.all(Object.entries(obj)
                .map(([name, value]) => this.setVar(name, value)));
        }
        else if (value !== undefined) {
            await this.setVar(obj, value);
        }
    }
    async unsetVar(name) {
        await this._cast(`unset_var`, { name });
    }
    async unset(names) {
        if (Array.isArray(names)) {
            Promise.all(names.map(name => this.unsetVar(name)));
        }
        else {
            return this.unsetVar(names);
        }
    }
    async getVar(name, defaultValue = undefined) {
        const { value } = (await this._call(`get_var`, { name }) ?? defaultValue);
        return value;
    }
    async get(names) {
        if (Array.isArray(names)) {
            return Promise.all(names.map(name => this.getVar(name)));
        }
        else {
            return this.getVar(names);
        }
    }
    async startTimer(timeout = 60) {
        await this._cast(`start_timer`, { timeout });
    }
    async stopTimer() {
        await this._cast(`stop_timer`);
    }
    async _sendNotification(type, text, target, name, pushOptions) {
        await this._cast(`notification`, { type, name, text, target, push_opts: pushOptions }, constants_1.NOTIFICATION_TIMEOUT);
    }
    async broadcast(name, text, target, pushOptions) {
        await this._sendNotification(Notification.BROADCAST, text, target, name, pushOptions);
    }
    async cancelBroadcast(name, target) {
        await this._sendNotification(Notification.CANCEL, undefined, target, name);
    }
    async notify(name, text, target, pushOptions) {
        await this._sendNotification(Notification.NOTIFY, text, target, name, pushOptions);
    }
    async cancelNotify(name, target) {
        await this._sendNotification(Notification.CANCEL, undefined, target, name);
    }
    async alert(name, text, target, pushOptions) {
        await this._sendNotification(Notification.ALERT, text, target, name, pushOptions);
    }
    async cancelAlert(name, target) {
        await this._sendNotification(Notification.CANCEL, undefined, target, name);
    }
    async listen(phrases = [], { transcribe = true, alt_lang = Language.ENGLISH, timeout = 60 } = {}) {
        const response = await this._call(`listen`, { transcribe, phrases, timeout, alt_lang }, timeout * 1000);
        if (transcribe) {
            return { text: response.text };
        }
        else {
            return { audio: response.audio };
        }
    }
    async createIncident(type) {
        const { incident_id } = await this._call(`create_incident`, { type });
        return incident_id;
    }
    async resolveIncident(incidentId, reason) {
        await this._cast(`resolve_incident`, { incident_id: incidentId, reason });
    }
    async terminate() {
        await this._cast(`terminate`);
    }
    _buildCallIdRequestOrThrow(arg) {
        if (typeof arg === `string`) {
            return { call_id: arg };
        }
        else if (typeof arg === `object`) {
            if (typeof arg.call_id === `string`) {
                return { call_id: arg.call_id };
            }
            else {
                throw new Error(`missing required parameter`);
            }
        }
        else {
            throw new Error(`invalid argument type`);
        }
    }
    async placeCall(call) {
        await this._cast(`call`, call);
    }
    async answerCall(callRequest) {
        await this._cast(`answer`, this._buildCallIdRequestOrThrow(callRequest));
    }
    async hangupCall(callRequest) {
        await this._cast(`hangup`, this._buildCallIdRequestOrThrow(callRequest));
    }
    async register(request) {
        await this._cast(`register`, request);
    }
}
const DEFAULT_WORKFLOW = `__default_relay_workflow__`;
let workflows = null;
let instances = null;
let server = null;
const initializeRelaySdk = (options = {}) => {
    if (workflows) {
        throw new Error(`Relay SDK already initialized`);
    }
    else {
        workflows = new Map();
        instances = new Map();
        const serverOptions = options.server ? { server: options.server } : { port: constants_1.PORT };
        server = new ws_1.default.Server(serverOptions, () => {
            console.log(`Relay SDK WebSocket Server listening => ${constants_1.PORT}`);
        });
        server.shouldHandle = (request) => {
            console.info(`WebSocket request =>`, request.url);
            if (request.url) {
                const path = request.url.slice(1);
                if (path) {
                    return !!workflows?.has(path);
                }
                else {
                    return !!workflows?.has(DEFAULT_WORKFLOW);
                }
            }
            else {
                return false;
            }
        };
        server.on(`connection`, (websocket, request) => {
            if (request.url && workflows) {
                const path = request.url.slice(1);
                const workflowName = workflows.has(path) ? path : DEFAULT_WORKFLOW;
                const workflow = workflows.get(workflowName);
                if (workflow) {
                    websocket.connectionId = `${workflowName}-${utils_1.makeId()}`;
                    websocket.isAlive = true;
                    websocket.on(`pong`, () => {
                        websocket.isAlive = true;
                    });
                    websocket.on(`close`, ( /*code, reason*/) => {
                        console.info(`Workflow closed =>`, websocket.connectionId);
                        instances?.delete(websocket.connectionId);
                    });
                    const adapter = new RelayEventAdapter(websocket);
                    workflow(adapter);
                    instances?.set(websocket.connectionId, adapter);
                    console.info(`Workflow connection =>`, websocket.connectionId);
                }
                else {
                    console.info(`Workflow not found; terminating websocket =>`, websocket.connectionId);
                    websocket.terminate();
                }
            }
        });
        server.on(`error`, err => {
            console.error(err);
        });
        setInterval(() => {
            server?.clients.forEach((websocket) => {
                const _websocket = websocket;
                if (_websocket.isAlive === false) {
                    return websocket.terminate();
                }
                _websocket.isAlive = false;
                websocket.ping(utils_1.noop);
            });
        }, constants_1.HEARTBEAT);
        return {
            workflow: (path, workflow) => {
                if (workflows) {
                    if ((typeof path === `function`)) {
                        console.info(`Default workflow set`);
                        workflows.set(DEFAULT_WORKFLOW, path);
                    }
                    else if (typeof path === `string` && typeof workflow === `function`) {
                        const strippedPath = path.replace(/^\/+/, ``);
                        workflows.set(strippedPath, workflow);
                    }
                    else {
                        throw new Error(`First argument for workflow must either be a string or a function`);
                    }
                }
            }
        };
    }
};
exports.relay = initializeRelaySdk;
